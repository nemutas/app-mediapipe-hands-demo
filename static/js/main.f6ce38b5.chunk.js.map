{"version":3,"sources":["utils/drawCanvas.ts","components/App.tsx","reportWebVitals.ts","index.tsx"],"names":["drawCircle","ctx","handLandmarks","length","width","canvas","height","x1","x","y1","y","x2","y2","r","Math","sqrt","pow","strokeStyle","lineWidth","beginPath","arc","PI","stroke","App","webcamRef","useRef","canvasRef","resultsRef","onResults","useCallback","results","current","save","clearRect","scale","translate","drawImage","image","multiHandLandmarks","landmarks","drawConnectors","HAND_CONNECTIONS","color","drawLandmarks","radius","restore","drawCanvas","getContext","useEffect","hands","Hands","locateFile","file","setOptions","maxNumHands","modelComplexity","minDetectionConfidence","minTrackingConfidence","camera","Camera","video","onFrame","a","send","start","className","styles","container","audio","style","visibility","ref","screenshotFormat","videoConstraints","facingMode","buttonContainer","button","onClick","console","log","css","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"sRAqCMA,EAAa,SAACC,EAA+BC,GAClD,GAA6B,IAAzBA,EAAcC,QAAgBD,EAAc,GAAGC,OAAS,GAAKD,EAAc,GAAGC,OAAS,EAAG,CAC7F,IAAMC,EAAQH,EAAII,OAAOD,MACnBE,EAASL,EAAII,OAAOC,OACnBC,EAAWL,EAAc,GAAG,GAAGM,EAAIJ,EAA/BK,EAAsCP,EAAc,GAAG,GAAGQ,EAAIJ,EAClEK,EAAWT,EAAc,GAAG,GAAGM,EAAIJ,EAA/BQ,EAAsCV,EAAc,GAAG,GAAGQ,EAAIJ,EACnEE,GAAKD,EAAKI,GAAM,EAChBD,GAAKD,EAAKG,GAAM,EAChBC,EAAIC,KAAKC,KAAKD,KAAKE,IAAIT,EAAKI,EAAI,GAAKG,KAAKE,IAAIP,EAAKG,EAAI,IAAM,EAEnEX,EAAIgB,YAAc,UAClBhB,EAAIiB,UAAY,EAChBjB,EAAIkB,YACJlB,EAAImB,IAAIZ,EAAGE,EAAGG,EAAG,EAAa,EAAVC,KAAKO,IAAQ,GACjCpB,EAAIqB,W,OCtCOC,EAAW,WACvB,IAAMC,EAAYC,iBAAe,MAC3BC,EAAYD,iBAA0B,MACtCE,EAAaF,iBAAY,MAMzBG,EAAYC,uBAAY,SAACC,GAC9BH,EAAWI,QAAUD,EDfG,SAAC7B,EAA+B6B,GACzD,IAAM1B,EAAQH,EAAII,OAAOD,MACnBE,EAASL,EAAII,OAAOC,OAU1B,GARAL,EAAI+B,OACJ/B,EAAIgC,UAAU,EAAG,EAAG7B,EAAOE,GAE3BL,EAAIiC,OAAO,EAAG,GACdjC,EAAIkC,WAAW/B,EAAO,GAEtBH,EAAImC,UAAUN,EAAQO,MAAO,EAAG,EAAGjC,EAAOE,GAEtCwB,EAAQQ,mBAAoB,qBAEPR,EAAQQ,oBAFD,IAE/B,2BAAoD,CAAC,IAA1CC,EAAyC,QACnDC,yBAAevC,EAAKsC,EAAWE,mBAAkB,CAAEC,MAAO,UAAWxB,UAAW,IAChFyB,wBAAc1C,EAAKsC,EAAW,CAAEG,MAAO,UAAWxB,UAAW,EAAG0B,OAAQ,KAJ1C,8BAO/B5C,EAAWC,EAAK6B,EAAQQ,oBAEzBrC,EAAI4C,UCHHC,CADkBpB,EAAUK,QAASgB,WAAW,MAC1BjB,KACpB,IAGHkB,qBAAU,WACT,IAAMC,EAAQ,IAAIC,QAAM,CACvBC,WAAY,SAAAC,GACX,MAAM,iDAAN,OAAwDA,MAa1D,GATAH,EAAMI,WAAW,CAChBC,YAAa,EACbC,gBAAiB,EACjBC,uBAAwB,GACxBC,sBAAuB,KAGxBR,EAAMrB,UAAUA,GAEiB,qBAAtBJ,EAAUO,SAAiD,OAAtBP,EAAUO,QAAkB,CAC3E,IAAM2B,EAAS,IAAIC,SAAOnC,EAAUO,QAAQ6B,MAAQ,CACnDC,QAAQ,WAAD,4BAAE,sBAAAC,EAAA,sEACFb,EAAMc,KAAK,CAAE1B,MAAOb,EAAUO,QAAS6B,QADrC,2CAAF,kDAAC,GAGRxD,MAAO,KACPE,OAAQ,MAEToD,EAAOM,WAEN,CAACpC,IAQJ,OACC,sBAAKqC,UAAWC,EAAOC,UAAvB,UAEC,cAAC,IAAD,CACCC,OAAO,EACPC,MAAO,CAAEC,WAAY,UACrBlE,MAAO,KACPE,OAAQ,IACRiE,IAAK/C,EACLgD,iBAAiB,aACjBC,iBAAkB,CAAErE,MAAO,KAAME,OAAQ,IAAKoE,WAAY,UAG3D,wBAAQH,IAAK7C,EAAWuC,UAAWC,EAAO7D,OAAQD,MAAO,KAAME,OAAQ,MAEvE,qBAAK2D,UAAWC,EAAOS,gBAAvB,SACC,wBAAQV,UAAWC,EAAOU,OAAQC,QArBlB,WAClB,IAAM/C,EAAUH,EAAWI,QAC3B+C,QAAQC,IAAIjD,EAAQQ,qBAmBlB,+BAWE4B,EAAS,CACdC,UAAWa,YAAF,iMAST3E,OAAQ2E,YAAF,4HAMNL,gBAAiBK,YAAF,wFAKfJ,OAAQI,YAAF,kMClGQC,EAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCHdQ,IAASC,OACR,cAAC,IAAMC,WAAP,UACC,cAAC,EAAD,MAEDC,SAASC,eAAe,SAMzBb,M","file":"static/js/main.f6ce38b5.chunk.js","sourcesContent":["import { drawConnectors, drawLandmarks } from '@mediapipe/drawing_utils';\r\nimport { HAND_CONNECTIONS, NormalizedLandmarkListList, Results } from '@mediapipe/hands';\r\n\r\n/**\r\n * cnavasに描画する\r\n * @param ctx canvas context\r\n * @param results 手の検出結果\r\n */\r\nexport const drawCanvas = (ctx: CanvasRenderingContext2D, results: Results) => {\r\n\tconst width = ctx.canvas.width\r\n\tconst height = ctx.canvas.height\r\n\r\n\tctx.save()\r\n\tctx.clearRect(0, 0, width, height)\r\n\t// canvas の左右反転\r\n\tctx.scale(-1, 1)\r\n\tctx.translate(-width, 0)\r\n\t// capture image の描画\r\n\tctx.drawImage(results.image, 0, 0, width, height)\r\n\t// 手の描画\r\n\tif (results.multiHandLandmarks) {\r\n\t\t// 骨格の描画\r\n\t\tfor (const landmarks of results.multiHandLandmarks) {\r\n\t\t\tdrawConnectors(ctx, landmarks, HAND_CONNECTIONS, { color: '#00FF00', lineWidth: 5 })\r\n\t\t\tdrawLandmarks(ctx, landmarks, { color: '#FF0000', lineWidth: 1, radius: 5 })\r\n\t\t}\r\n\t\t// 円の描画\r\n\t\tdrawCircle(ctx, results.multiHandLandmarks)\r\n\t}\r\n\tctx.restore()\r\n}\r\n\r\n/**\r\n *  人差し指の先端と人差し指の先端の間に円を描く\r\n * @param ctx\r\n * @param handLandmarks\r\n */\r\nconst drawCircle = (ctx: CanvasRenderingContext2D, handLandmarks: NormalizedLandmarkListList) => {\r\n\tif (handLandmarks.length === 2 && handLandmarks[0].length > 8 && handLandmarks[1].length > 8) {\r\n\t\tconst width = ctx.canvas.width\r\n\t\tconst height = ctx.canvas.height\r\n\t\tconst [x1, y1] = [handLandmarks[0][8].x * width, handLandmarks[0][8].y * height]\r\n\t\tconst [x2, y2] = [handLandmarks[1][8].x * width, handLandmarks[1][8].y * height]\r\n\t\tconst x = (x1 + x2) / 2\r\n\t\tconst y = (y1 + y2) / 2\r\n\t\tconst r = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2)) / 2\r\n\r\n\t\tctx.strokeStyle = '#0082cf'\r\n\t\tctx.lineWidth = 5\r\n\t\tctx.beginPath()\r\n\t\tctx.arc(x, y, r, 0, Math.PI * 2, true)\r\n\t\tctx.stroke()\r\n\t}\r\n}\r\n","// https://google.github.io/mediapipe/solutions/hands\n// https://google.github.io/mediapipe/getting_started/javascript.html\n// https://github.com/google/mediapipe\n// https://stackoverflow.com/questions/67674453/how-to-run-mediapipe-facemesh-on-a-es6-node-js-environment-alike-react\n// https://www.npmjs.com/package/react-webcam\n\nimport React, { useCallback, useEffect, useRef, VFC } from 'react';\nimport Webcam from 'react-webcam';\nimport { css } from '@emotion/css';\nimport { Camera } from '@mediapipe/camera_utils';\nimport { Hands, Results } from '@mediapipe/hands';\nimport { drawCanvas } from '../utils/drawCanvas';\n\nexport const App: VFC = () => {\n\tconst webcamRef = useRef<Webcam>(null)\n\tconst canvasRef = useRef<HTMLCanvasElement>(null)\n\tconst resultsRef = useRef<any>(null)\n\n\t/**\n\t * 検出結果（フレーム毎に呼び出される）\n\t * @param results\n\t */\n\tconst onResults = useCallback((results: Results) => {\n\t\tresultsRef.current = results\n\n\t\tconst canvasCtx = canvasRef.current!.getContext('2d')!\n\t\tdrawCanvas(canvasCtx, results)\n\t}, [])\n\n\t// 初期設定\n\tuseEffect(() => {\n\t\tconst hands = new Hands({\n\t\t\tlocateFile: file => {\n\t\t\t\treturn `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`\n\t\t\t}\n\t\t})\n\n\t\thands.setOptions({\n\t\t\tmaxNumHands: 2,\n\t\t\tmodelComplexity: 1,\n\t\t\tminDetectionConfidence: 0.5,\n\t\t\tminTrackingConfidence: 0.5\n\t\t})\n\n\t\thands.onResults(onResults)\n\n\t\tif (typeof webcamRef.current !== 'undefined' && webcamRef.current !== null) {\n\t\t\tconst camera = new Camera(webcamRef.current.video!, {\n\t\t\t\tonFrame: async () => {\n\t\t\t\t\tawait hands.send({ image: webcamRef.current!.video! })\n\t\t\t\t},\n\t\t\t\twidth: 1280,\n\t\t\t\theight: 720\n\t\t\t})\n\t\t\tcamera.start()\n\t\t}\n\t}, [onResults])\n\n\t/** 検出結果をconsoleに出力する */\n\tconst OutputData = () => {\n\t\tconst results = resultsRef.current as Results\n\t\tconsole.log(results.multiHandLandmarks)\n\t}\n\n\treturn (\n\t\t<div className={styles.container}>\n\t\t\t{/* capture */}\n\t\t\t<Webcam\n\t\t\t\taudio={false}\n\t\t\t\tstyle={{ visibility: 'hidden' }}\n\t\t\t\twidth={1280}\n\t\t\t\theight={720}\n\t\t\t\tref={webcamRef}\n\t\t\t\tscreenshotFormat=\"image/jpeg\"\n\t\t\t\tvideoConstraints={{ width: 1280, height: 720, facingMode: 'user' }}\n\t\t\t/>\n\t\t\t{/* draw */}\n\t\t\t<canvas ref={canvasRef} className={styles.canvas} width={1280} height={720} />\n\t\t\t{/* output */}\n\t\t\t<div className={styles.buttonContainer}>\n\t\t\t\t<button className={styles.button} onClick={OutputData}>\n\t\t\t\t\tOutput Data\n\t\t\t\t</button>\n\t\t\t</div>\n\t\t</div>\n\t)\n}\n\n// ==============================================\n// styles\n\nconst styles = {\n\tcontainer: css`\n\t\tposition: relative;\n\t\twidth: 100vw;\n\t\theight: 100vh;\n\t\toverflow: hidden;\n\t\tdisplay: flex;\n\t\tjustify-content: center;\n\t\talign-items: center;\n\t`,\n\tcanvas: css`\n\t\tposition: absolute;\n\t\twidth: 1280px;\n\t\theight: 720px;\n\t\tbackground-color: #fff;\n\t`,\n\tbuttonContainer: css`\n\t\tposition: absolute;\n\t\ttop: 20px;\n\t\tleft: 20px;\n\t`,\n\tbutton: css`\n\t\tcolor: #fff;\n\t\tbackground-color: #0082cf;\n\t\tfont-size: 1rem;\n\t\tborder: none;\n\t\tborder-radius: 5px;\n\t\tpadding: 10px 10px;\n\t\tcursor: pointer;\n\t`\n}\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import './index.css';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { App } from './components/App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n\t<React.StrictMode>\n\t\t<App />\n\t</React.StrictMode>,\n\tdocument.getElementById('root')\n)\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals()\n"],"sourceRoot":""}