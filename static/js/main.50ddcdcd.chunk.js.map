{"version":3,"sources":["components/App.tsx","reportWebVitals.ts","index.tsx"],"names":["App","webcamRef","useRef","canvasRef","resultsRef","onResults","useCallback","results","current","canvasCtx","getContext","width","canvas","height","save","clearRect","scale","translate","drawImage","image","multiHandLandmarks","landmarks","drawConnectors","HAND_CONNECTIONS","color","lineWidth","drawLandmarks","radius","ctx","handLandmarks","length","x1","x","y1","y","x2","y2","r","Math","sqrt","pow","strokeStyle","beginPath","arc","PI","stroke","drawCircle","restore","useEffect","hands","Hands","locateFile","file","setOptions","maxNumHands","modelComplexity","minDetectionConfidence","minTrackingConfidence","camera","Camera","video","onFrame","a","send","start","className","styles","container","audio","style","visibility","ref","screenshotFormat","videoConstraints","facingMode","buttonContainer","button","onClick","console","log","css","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.50ddcdcd.chunk.js","sourcesContent":["// https://google.github.io/mediapipe/solutions/hands\n// https://google.github.io/mediapipe/getting_started/javascript.html\n// https://github.com/google/mediapipe\n// https://stackoverflow.com/questions/67674453/how-to-run-mediapipe-facemesh-on-a-es6-node-js-environment-alike-react\n// https://www.npmjs.com/package/react-webcam\n\nimport React, { useCallback, useEffect, useRef, VFC } from 'react';\nimport Webcam from 'react-webcam';\nimport { css } from '@emotion/css';\nimport { Camera } from '@mediapipe/camera_utils';\nimport { drawConnectors, drawLandmarks } from '@mediapipe/drawing_utils';\nimport { HAND_CONNECTIONS, Hands, NormalizedLandmarkListList, Results } from '@mediapipe/hands';\n\nexport const App: VFC = () => {\n\tconst webcamRef = useRef<Webcam>(null)\n\tconst canvasRef = useRef<HTMLCanvasElement>(null)\n\tconst resultsRef = useRef<any>(null)\n\n\t/**\n\t *  人差し指の先端と人差し指の先端の間に円を描く\n\t * @param ctx\n\t * @param handLandmarks\n\t */\n\tconst drawCircle = (ctx: CanvasRenderingContext2D, handLandmarks: NormalizedLandmarkListList) => {\n\t\tif (handLandmarks.length === 2 && handLandmarks[0].length > 8 && handLandmarks[1].length > 8) {\n\t\t\tconst width = ctx.canvas.width\n\t\t\tconst height = ctx.canvas.height\n\t\t\tconst [x1, y1] = [handLandmarks[0][8].x * width, handLandmarks[0][8].y * height]\n\t\t\tconst [x2, y2] = [handLandmarks[1][8].x * width, handLandmarks[1][8].y * height]\n\t\t\tconst x = (x1 + x2) / 2\n\t\t\tconst y = (y1 + y2) / 2\n\t\t\tconst r = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2)) / 2\n\n\t\t\tctx.strokeStyle = '#0082cf'\n\t\t\tctx.lineWidth = 3\n\t\t\tctx.beginPath()\n\t\t\tctx.arc(x, y, r, 0, Math.PI * 2, true)\n\t\t\tctx.stroke()\n\t\t}\n\t}\n\n\t/**\n\t * 検出結果（フレーム毎に呼び出される）\n\t * @param results\n\t */\n\tconst onResults = useCallback((results: Results) => {\n\t\tresultsRef.current = results\n\n\t\tconst canvasCtx = canvasRef.current!.getContext('2d')!\n\t\tconst width = canvasCtx.canvas.width\n\t\tconst height = canvasCtx.canvas.height\n\n\t\tcanvasCtx.save()\n\t\tcanvasCtx.clearRect(0, 0, width, height)\n\t\t// canvas の左右反転\n\t\tcanvasCtx.scale(-1, 1)\n\t\tcanvasCtx.translate(-width, 0)\n\t\t// capture image の描画\n\t\tcanvasCtx.drawImage(results.image, 0, 0, width, height)\n\t\t// 手の描画\n\t\tif (results.multiHandLandmarks) {\n\t\t\t// 骨格の描画\n\t\t\tfor (const landmarks of results.multiHandLandmarks) {\n\t\t\t\tdrawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, { color: '#00FF00', lineWidth: 1 })\n\t\t\t\tdrawLandmarks(canvasCtx, landmarks, { color: '#FF0000', lineWidth: 1, radius: 2 })\n\t\t\t}\n\t\t\t// 円の描画\n\t\t\tdrawCircle(canvasCtx, results.multiHandLandmarks)\n\t\t}\n\t\tcanvasCtx.restore()\n\t}, [])\n\n\t// 初期設定\n\tuseEffect(() => {\n\t\tconst hands = new Hands({\n\t\t\tlocateFile: file => {\n\t\t\t\treturn `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`\n\t\t\t}\n\t\t})\n\n\t\thands.setOptions({\n\t\t\tmaxNumHands: 2,\n\t\t\tmodelComplexity: 1,\n\t\t\tminDetectionConfidence: 0.5,\n\t\t\tminTrackingConfidence: 0.5\n\t\t})\n\n\t\thands.onResults(onResults)\n\n\t\tif (typeof webcamRef.current !== 'undefined' && webcamRef.current !== null) {\n\t\t\tconst camera = new Camera(webcamRef.current.video!, {\n\t\t\t\tonFrame: async () => {\n\t\t\t\t\tawait hands.send({ image: webcamRef.current!.video! })\n\t\t\t\t},\n\t\t\t\twidth: 1280,\n\t\t\t\theight: 720\n\t\t\t})\n\t\t\tcamera.start()\n\t\t}\n\t}, [onResults])\n\n\t/** 検出結果をconsoleに出力する */\n\tconst OutputData = () => {\n\t\tconst results = resultsRef.current as Results\n\t\tconsole.log(results.multiHandLandmarks)\n\t}\n\n\tconst videoConstraints = {\n\t\twidth: 1280,\n\t\theight: 720,\n\t\tfacingMode: 'user'\n\t}\n\n\treturn (\n\t\t<div className={styles.container}>\n\t\t\t{/* capture */}\n\t\t\t<Webcam\n\t\t\t\taudio={false}\n\t\t\t\tstyle={{ visibility: 'hidden' }}\n\t\t\t\twidth={1280}\n\t\t\t\theight={720}\n\t\t\t\tref={webcamRef}\n\t\t\t\tscreenshotFormat=\"image/jpeg\"\n\t\t\t\tvideoConstraints={videoConstraints}\n\t\t\t/>\n\t\t\t{/* draw */}\n\t\t\t<canvas ref={canvasRef} className={styles.canvas} />\n\t\t\t{/* output */}\n\t\t\t<div className={styles.buttonContainer}>\n\t\t\t\t<button className={styles.button} onClick={OutputData}>\n\t\t\t\t\tOutput Data\n\t\t\t\t</button>\n\t\t\t</div>\n\t\t</div>\n\t)\n}\n\n// ==============================================\n// styles\n\nconst styles = {\n\tcontainer: css`\n\t\tposition: relative;\n\t\twidth: 100vw;\n\t\theight: 100vh;\n\t\toverflow: hidden;\n\t\tdisplay: flex;\n\t\tjustify-content: center;\n\t\talign-items: center;\n\t`,\n\tcanvas: css`\n\t\tposition: absolute;\n\t\twidth: 1280px;\n\t\theight: 720px;\n\t\tbackground-color: #fff;\n\t`,\n\tbuttonContainer: css`\n\t\tposition: absolute;\n\t\ttop: 20px;\n\t\tleft: 20px;\n\t`,\n\tbutton: css`\n\t\tcolor: #fff;\n\t\tbackground-color: #0082cf;\n\t\tfont-size: 1rem;\n\t\tborder: none;\n\t\tborder-radius: 5px;\n\t\tpadding: 10px 10px;\n\t\tcursor: pointer;\n\t`\n}\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import './index.css';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { App } from './components/App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n\t<React.StrictMode>\n\t\t<App />\n\t</React.StrictMode>,\n\tdocument.getElementById('root')\n)\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals()\n"],"sourceRoot":""}